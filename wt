#!/bin/bash

set -e

usage() {
    cat << EOF
Usage: wt <command> [options]

Commands:
    status    Show clean status overview of all worktrees
              -v, --verbose  Show detailed file lists and commits
    list      List all worktrees (with lock status)
    locked    List only locked worktrees
    cleanup   Remove all locked worktrees
    lock      Lock worktree(s): wt lock <path> [path2 ...]
    unlock    Unlock worktree(s): wt unlock <path> [path2 ...]
    run       Run command in worktrees: wt run [--locked|--all] -- <command>
    help      Show this help

Examples:
    wt status
    wt status -v
    wt list
    wt locked
    wt cleanup
    wt lock /path/to/worktree
    wt unlock /path/to/worktree
    wt lock /path/worktree-* /other/worktree
    wt unlock */worktree-{1,2}
    wt run -- git clean -dfx
    wt run --locked -- git status
    wt run --all -- npm install
EOF
}

require_repo() {
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        echo "Error: Not in a git repository" >&2
        exit 1
    fi
}

get_worktrees() {
    git worktree list --porcelain | awk '
    function emit() {
        if (path != "") {
            printf "%s\t%d\n", path, locked;
        }
    }
    BEGIN {
        path = "";
        locked = 0;
    }
    {
        key = $1;
        if (key == "worktree") {
            emit();
            path = substr($0, index($0, " ") + 1);
            locked = 0;
        } else if (key == "locked") {
            locked = 1;
        } else if ($0 == "") {
            emit();
            path = "";
            locked = 0;
        }
    }
    END {
        emit();
    }'
}

list_worktrees() {
    require_repo
    
    git worktree list
}

list_locked() {
    require_repo

    local found=0
    while IFS=$'\t' read -r formatted path locked_flag; do
        if [ "$locked_flag" -eq 1 ]; then
            echo "$formatted"
            found=1
        fi
    done < <(paste <(git worktree list) <(get_worktrees))

    if [ "$found" -eq 0 ]; then
        echo "No locked worktrees found"
    fi
}

status_worktrees() {
    require_repo

    local verbose=0
    if [ "${1:-}" = "-v" ] || [ "${1:-}" = "--verbose" ]; then
        verbose=1
    fi

    local RED='\033[0;31m'
    local GREEN='\033[0;32m'
    local YELLOW='\033[1;33m'
    local BLUE='\033[0;34m'
    local CYAN='\033[0;36m'
    local GRAY='\033[0;90m'
    local BOLD='\033[1m'
    local RESET='\033[0m'

    local worktree_count=0
    while IFS=$'\t' read -r wt_path locked; do
        ((++worktree_count))

        local wt_name
        wt_name=$(basename "$wt_path")
        if [ "$locked" -eq 1 ]; then
            echo -e "${BOLD}${YELLOW}ðŸ”’ $wt_name${RESET} ${GRAY}(locked)${RESET}"
        else
            echo -e "${BOLD}${CYAN}$wt_name${RESET}"
        fi
        echo -e "${GRAY}   $wt_path${RESET}"

        (
            cd "$wt_path" || exit 0

            local branch
            branch=$(git symbolic-ref --short HEAD 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")
            echo -e "   ${BLUE}branch:${RESET} $branch"

            local upstream
            upstream=$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null || true)
            if [ -n "$upstream" ]; then
                local ahead behind
                ahead=$(git rev-list --count '@{u}'..HEAD 2>/dev/null || echo "0")
                behind=$(git rev-list --count HEAD..'@{u}' 2>/dev/null || echo "0")

                if [ "$ahead" -gt 0 ] || [ "$behind" -gt 0 ]; then
                    local tracking_info=""
                    [ "$ahead" -gt 0 ] && tracking_info="${GREEN}â†‘$ahead${RESET}"
                    [ "$behind" -gt 0 ] && tracking_info="${tracking_info}${tracking_info:+ }${RED}â†“$behind${RESET}"
                    echo -e "   ${BLUE}remote:${RESET} $upstream ($tracking_info)"

                    if [ "$verbose" -eq 1 ] && [ "$ahead" -gt 0 ]; then
                        echo -e "   ${GRAY}ahead commits:${RESET}"
                        git log --oneline '@{u}'..HEAD 2>/dev/null | while read -r commit_line; do
                            echo -e "     ${GREEN}+${RESET} $commit_line"
                        done
                    fi

                    if [ "$verbose" -eq 1 ] && [ "$behind" -gt 0 ]; then
                        echo -e "   ${GRAY}behind commits:${RESET}"
                        git log --oneline HEAD..'@{u}' 2>/dev/null | while read -r commit_line; do
                            echo -e "     ${RED}-${RESET} $commit_line"
                        done
                    fi
                else
                    echo -e "   ${BLUE}remote:${RESET} $upstream ${GREEN}âœ“${RESET}"
                fi
            fi

            local staged unstaged untracked
            staged=$(git diff --cached --numstat 2>/dev/null | wc -l)
            unstaged=$(git diff --numstat 2>/dev/null | wc -l)
            untracked=$(git ls-files --others --exclude-standard 2>/dev/null | wc -l)

            if [ "$staged" -eq 0 ] && [ "$unstaged" -eq 0 ] && [ "$untracked" -eq 0 ]; then
                echo -e "   ${BLUE}status:${RESET} ${GREEN}clean${RESET}"
            else
                local status_parts=()
                [ "$staged" -gt 0 ] && status_parts+=("${GREEN}$staged staged${RESET}")
                [ "$unstaged" -gt 0 ] && status_parts+=("${YELLOW}$unstaged modified${RESET}")
                [ "$untracked" -gt 0 ] && status_parts+=("${RED}$untracked untracked${RESET}")

                echo -e "   ${BLUE}status:${RESET} $(IFS=', '; echo -e "${status_parts[*]}")"

                if [ "$verbose" -eq 1 ] && [ "$staged" -gt 0 ]; then
                    echo -e "   ${GRAY}staged files:${RESET}"
                    git diff --cached --name-status 2>/dev/null | while read -r status_char file; do
                        echo -e "     ${GREEN}$status_char${RESET} $file"
                    done
                fi

                if [ "$verbose" -eq 1 ] && [ "$unstaged" -gt 0 ]; then
                    echo -e "   ${GRAY}modified files:${RESET}"
                    git diff --name-status 2>/dev/null | while read -r status_char file; do
                        echo -e "     ${YELLOW}$status_char${RESET} $file"
                    done
                fi

                if [ "$verbose" -eq 1 ] && [ "$untracked" -gt 0 ]; then
                    echo -e "   ${GRAY}untracked files:${RESET}"
                    git ls-files --others --exclude-standard 2>/dev/null | while read -r file; do
                        echo -e "     ${RED}?${RESET} $file"
                    done
                fi
            fi
        ) || true

        echo
    done < <(get_worktrees)

    if [ "$worktree_count" -eq 0 ]; then
        echo "No worktrees found"
    fi
}

cleanup_locked() {
    require_repo

    local locked_worktrees=()
    while IFS=$'\t' read -r path status; do
        if [ "$status" -eq 1 ]; then
            locked_worktrees+=("$path")
        fi
    done < <(get_worktrees)

    if [ ${#locked_worktrees[@]} -eq 0 ]; then
        echo "No locked worktrees found"
        return 0
    fi

    echo "Found locked worktrees:"
    printf '  %s\n' "${locked_worktrees[@]}"
    echo

    read -p "Remove all locked worktrees? [y/N]: " -n 1 -r
    echo

    if [[ $REPLY =~ ^[Yy]$ ]]; then
        for worktree_path in "${locked_worktrees[@]}"; do
            echo "Removing: $worktree_path"
            git worktree remove -f -f "$worktree_path" --force
        done
        echo "Cleanup complete"
    else
        echo "Cleanup cancelled"
    fi
}

lock_worktree() {
    require_repo

    if [ $# -eq 0 ]; then
        echo "Error: Please specify at least one worktree path" >&2
        exit 1
    fi

    declare -A worktree_status
    while IFS=$'\t' read -r wt_path status; do
        worktree_status["$wt_path"]="$status"
    done < <(get_worktrees)

    local paths_to_lock=()
    for path in "$@"; do
        if [ ! -d "$path" ]; then
            echo "Warning: Skipping non-existent path: $path" >&2
        else
            local abs_path
            abs_path=$(cd "$path" && pwd)

            if [ "${worktree_status[$abs_path]}" = "1" ]; then
                echo "Already locked: $path"
            elif [ -n "${worktree_status[$abs_path]+_}" ]; then
                paths_to_lock+=("$path")
            else
                echo "Warning: Not a worktree: $path" >&2
            fi
        fi
    done

    if [ ${#paths_to_lock[@]} -eq 0 ]; then
        echo "No worktrees to lock"
        exit 0
    fi

    if [ ${#paths_to_lock[@]} -gt 1 ]; then
        echo "About to lock ${#paths_to_lock[@]} worktree(s):"
        printf '  %s\n' "${paths_to_lock[@]}"
        echo
        read -p "Continue? [y/N]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Operation cancelled"
            exit 0
        fi
    fi

    for path in "${paths_to_lock[@]}"; do
        git worktree lock "$path"
        echo "Locked: $path"
    done
}

unlock_worktree() {
    require_repo

    if [ $# -eq 0 ]; then
        echo "Error: Please specify at least one worktree path" >&2
        exit 1
    fi

    declare -A worktree_status
    while IFS=$'\t' read -r wt_path status; do
        worktree_status["$wt_path"]="$status"
    done < <(get_worktrees)

    local paths_to_unlock=()
    for path in "$@"; do
        if [ ! -d "$path" ]; then
            echo "Warning: Skipping non-existent path: $path" >&2
        else
            local abs_path
            abs_path=$(cd "$path" && pwd)

            if [ "${worktree_status[$abs_path]}" = "0" ]; then
                echo "Not locked: $path"
            elif [ "${worktree_status[$abs_path]}" = "1" ]; then
                paths_to_unlock+=("$path")
            else
                echo "Warning: Not a worktree: $path" >&2
            fi
        fi
    done

    if [ ${#paths_to_unlock[@]} -eq 0 ]; then
        echo "No worktrees to unlock"
        exit 0
    fi

    if [ ${#paths_to_unlock[@]} -gt 1 ]; then
        echo "About to unlock ${#paths_to_unlock[@]} worktree(s):"
        printf '  %s\n' "${paths_to_unlock[@]}"
        echo
        read -p "Continue? [y/N]: " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Operation cancelled"
            exit 0
        fi
    fi

    for path in "${paths_to_unlock[@]}"; do
        git worktree unlock "$path"
        echo "Unlocked: $path"
    done
}

run_in_worktrees() {
    require_repo

    local mode="unlocked"
    local command_args=()
    local found_separator=false

    while [ $# -gt 0 ]; do
        case "$1" in
            --locked)
                mode="locked"
                shift
                ;;
            --all)
                mode="all"
                shift
                ;;
            --)
                found_separator=true
                shift
                command_args=("$@")
                break
                ;;
            *)
                echo "Error: Unknown option '$1'. Use -- to separate command" >&2
                exit 1
                ;;
        esac
    done

    if [ "$found_separator" = false ]; then
        echo "Error: Missing -- separator before command" >&2
        echo "Usage: wt run [--locked|--all] -- <command>" >&2
        exit 1
    fi

    if [ ${#command_args[@]} -eq 0 ]; then
        echo "Error: No command specified after --" >&2
        exit 1
    fi

    local worktree_paths=()
    while IFS=$'\t' read -r wt_path status; do
        case "$mode" in
            locked)
                [ "$status" -eq 1 ] && worktree_paths+=("$wt_path")
                ;;
            unlocked)
                [ "$status" -eq 0 ] && worktree_paths+=("$wt_path")
                ;;
            all)
                worktree_paths+=("$wt_path")
                ;;
        esac
    done < <(get_worktrees)

    if [ ${#worktree_paths[@]} -eq 0 ]; then
        echo "No $mode worktrees found"
        exit 0
    fi

    echo "About to run command in ${#worktree_paths[@]} $mode worktree(s):"
    printf '  %s\n' "${worktree_paths[@]}"
    echo
    echo "Command: ${command_args[*]}"
    echo
    read -p "Continue? [y/N]: " -n 1 -r
    echo

    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        echo "Operation cancelled"
        exit 0
    fi

    local failed=0
    for wt_path in "${worktree_paths[@]}"; do
        echo
        echo "==> Running in: $wt_path"
        if (cd "$wt_path" && "${command_args[@]}"); then
            echo "==> Success: $wt_path"
        else
            echo "==> Failed: $wt_path (exit code: $?)" >&2
            ((failed++))
        fi
    done

    echo
    if [ $failed -eq 0 ]; then
        echo "All commands completed successfully"
    else
        echo "Warning: $failed command(s) failed" >&2
        exit 1
    fi
}

case "${1:-help}" in
    status|st)
        shift
        status_worktrees "$@"
        ;;
    list|ls)
        list_worktrees
        ;;
    locked)
        list_locked
        ;;
    cleanup|clean)
        cleanup_locked
        ;;
    lock)
        shift
        lock_worktree "$@"
        ;;
    unlock)
        shift
        unlock_worktree "$@"
        ;;
    run|exec)
        shift
        run_in_worktrees "$@"
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        echo "Error: Unknown command '$1'" >&2
        echo
        usage
        exit 1
        ;;
esac
